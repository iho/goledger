// Code generated by MockGen. DO NOT EDIT.
// Source: internal/usecase/interfaces.go
//
// Generated by this command:
//
//	mockgen -source=internal/usecase/interfaces.go -destination=internal/usecase/mocks/mock_interfaces.go -package=mocks
//

// Package mocks is a generated GoMock package.
package mocks

import (
	context "context"
	reflect "reflect"
	time "time"

	domain "github.com/iho/goledger/internal/domain"
	usecase "github.com/iho/goledger/internal/usecase"
	decimal "github.com/shopspring/decimal"
	gomock "go.uber.org/mock/gomock"
)

// MockAccountRepository is a mock of AccountRepository interface.
type MockAccountRepository struct {
	ctrl     *gomock.Controller
	recorder *MockAccountRepositoryMockRecorder
	isgomock struct{}
}

// MockAccountRepositoryMockRecorder is the mock recorder for MockAccountRepository.
type MockAccountRepositoryMockRecorder struct {
	mock *MockAccountRepository
}

// NewMockAccountRepository creates a new mock instance.
func NewMockAccountRepository(ctrl *gomock.Controller) *MockAccountRepository {
	mock := &MockAccountRepository{ctrl: ctrl}
	mock.recorder = &MockAccountRepositoryMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockAccountRepository) EXPECT() *MockAccountRepositoryMockRecorder {
	return m.recorder
}

// Create mocks base method.
func (m *MockAccountRepository) Create(ctx context.Context, account *domain.Account) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Create", ctx, account)
	ret0, _ := ret[0].(error)
	return ret0
}

// Create indicates an expected call of Create.
func (mr *MockAccountRepositoryMockRecorder) Create(ctx, account any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Create", reflect.TypeOf((*MockAccountRepository)(nil).Create), ctx, account)
}

// CreateTx mocks base method.
func (m *MockAccountRepository) CreateTx(ctx context.Context, tx usecase.Transaction, account *domain.Account) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CreateTx", ctx, tx, account)
	ret0, _ := ret[0].(error)
	return ret0
}

// CreateTx indicates an expected call of CreateTx.
func (mr *MockAccountRepositoryMockRecorder) CreateTx(ctx, tx, account any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CreateTx", reflect.TypeOf((*MockAccountRepository)(nil).CreateTx), ctx, tx, account)
}

// GetByID mocks base method.
func (m *MockAccountRepository) GetByID(ctx context.Context, id string) (*domain.Account, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetByID", ctx, id)
	ret0, _ := ret[0].(*domain.Account)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetByID indicates an expected call of GetByID.
func (mr *MockAccountRepositoryMockRecorder) GetByID(ctx, id any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetByID", reflect.TypeOf((*MockAccountRepository)(nil).GetByID), ctx, id)
}

// GetByIDForUpdate mocks base method.
func (m *MockAccountRepository) GetByIDForUpdate(ctx context.Context, tx usecase.Transaction, id string) (*domain.Account, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetByIDForUpdate", ctx, tx, id)
	ret0, _ := ret[0].(*domain.Account)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetByIDForUpdate indicates an expected call of GetByIDForUpdate.
func (mr *MockAccountRepositoryMockRecorder) GetByIDForUpdate(ctx, tx, id any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetByIDForUpdate", reflect.TypeOf((*MockAccountRepository)(nil).GetByIDForUpdate), ctx, tx, id)
}

// GetByIDsForUpdate mocks base method.
func (m *MockAccountRepository) GetByIDsForUpdate(ctx context.Context, tx usecase.Transaction, ids []string) ([]*domain.Account, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetByIDsForUpdate", ctx, tx, ids)
	ret0, _ := ret[0].([]*domain.Account)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetByIDsForUpdate indicates an expected call of GetByIDsForUpdate.
func (mr *MockAccountRepositoryMockRecorder) GetByIDsForUpdate(ctx, tx, ids any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetByIDsForUpdate", reflect.TypeOf((*MockAccountRepository)(nil).GetByIDsForUpdate), ctx, tx, ids)
}

// List mocks base method.
func (m *MockAccountRepository) List(ctx context.Context, limit, offset int) ([]*domain.Account, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "List", ctx, limit, offset)
	ret0, _ := ret[0].([]*domain.Account)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// List indicates an expected call of List.
func (mr *MockAccountRepositoryMockRecorder) List(ctx, limit, offset any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "List", reflect.TypeOf((*MockAccountRepository)(nil).List), ctx, limit, offset)
}

// UpdateBalance mocks base method.
func (m *MockAccountRepository) UpdateBalance(ctx context.Context, tx usecase.Transaction, id string, balance decimal.Decimal, updatedAt time.Time) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "UpdateBalance", ctx, tx, id, balance, updatedAt)
	ret0, _ := ret[0].(error)
	return ret0
}

// UpdateBalance indicates an expected call of UpdateBalance.
func (mr *MockAccountRepositoryMockRecorder) UpdateBalance(ctx, tx, id, balance, updatedAt any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UpdateBalance", reflect.TypeOf((*MockAccountRepository)(nil).UpdateBalance), ctx, tx, id, balance, updatedAt)
}

// UpdateEncumberedBalance mocks base method.
func (m *MockAccountRepository) UpdateEncumberedBalance(ctx context.Context, tx usecase.Transaction, id string, encumberedBalance decimal.Decimal, updatedAt time.Time) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "UpdateEncumberedBalance", ctx, tx, id, encumberedBalance, updatedAt)
	ret0, _ := ret[0].(error)
	return ret0
}

// UpdateEncumberedBalance indicates an expected call of UpdateEncumberedBalance.
func (mr *MockAccountRepositoryMockRecorder) UpdateEncumberedBalance(ctx, tx, id, encumberedBalance, updatedAt any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UpdateEncumberedBalance", reflect.TypeOf((*MockAccountRepository)(nil).UpdateEncumberedBalance), ctx, tx, id, encumberedBalance, updatedAt)
}

// MockTransferRepository is a mock of TransferRepository interface.
type MockTransferRepository struct {
	ctrl     *gomock.Controller
	recorder *MockTransferRepositoryMockRecorder
	isgomock struct{}
}

// MockTransferRepositoryMockRecorder is the mock recorder for MockTransferRepository.
type MockTransferRepositoryMockRecorder struct {
	mock *MockTransferRepository
}

// NewMockTransferRepository creates a new mock instance.
func NewMockTransferRepository(ctrl *gomock.Controller) *MockTransferRepository {
	mock := &MockTransferRepository{ctrl: ctrl}
	mock.recorder = &MockTransferRepositoryMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockTransferRepository) EXPECT() *MockTransferRepositoryMockRecorder {
	return m.recorder
}

// Create mocks base method.
func (m *MockTransferRepository) Create(ctx context.Context, tx usecase.Transaction, transfer *domain.Transfer) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Create", ctx, tx, transfer)
	ret0, _ := ret[0].(error)
	return ret0
}

// Create indicates an expected call of Create.
func (mr *MockTransferRepositoryMockRecorder) Create(ctx, tx, transfer any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Create", reflect.TypeOf((*MockTransferRepository)(nil).Create), ctx, tx, transfer)
}

// GetByID mocks base method.
func (m *MockTransferRepository) GetByID(ctx context.Context, id string) (*domain.Transfer, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetByID", ctx, id)
	ret0, _ := ret[0].(*domain.Transfer)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetByID indicates an expected call of GetByID.
func (mr *MockTransferRepositoryMockRecorder) GetByID(ctx, id any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetByID", reflect.TypeOf((*MockTransferRepository)(nil).GetByID), ctx, id)
}

// ListByAccount mocks base method.
func (m *MockTransferRepository) ListByAccount(ctx context.Context, accountID string, limit, offset int) ([]*domain.Transfer, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ListByAccount", ctx, accountID, limit, offset)
	ret0, _ := ret[0].([]*domain.Transfer)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ListByAccount indicates an expected call of ListByAccount.
func (mr *MockTransferRepositoryMockRecorder) ListByAccount(ctx, accountID, limit, offset any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ListByAccount", reflect.TypeOf((*MockTransferRepository)(nil).ListByAccount), ctx, accountID, limit, offset)
}

// MockEntryRepository is a mock of EntryRepository interface.
type MockEntryRepository struct {
	ctrl     *gomock.Controller
	recorder *MockEntryRepositoryMockRecorder
	isgomock struct{}
}

// MockEntryRepositoryMockRecorder is the mock recorder for MockEntryRepository.
type MockEntryRepositoryMockRecorder struct {
	mock *MockEntryRepository
}

// NewMockEntryRepository creates a new mock instance.
func NewMockEntryRepository(ctrl *gomock.Controller) *MockEntryRepository {
	mock := &MockEntryRepository{ctrl: ctrl}
	mock.recorder = &MockEntryRepositoryMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockEntryRepository) EXPECT() *MockEntryRepositoryMockRecorder {
	return m.recorder
}

// Create mocks base method.
func (m *MockEntryRepository) Create(ctx context.Context, tx usecase.Transaction, entry *domain.Entry) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Create", ctx, tx, entry)
	ret0, _ := ret[0].(error)
	return ret0
}

// Create indicates an expected call of Create.
func (mr *MockEntryRepositoryMockRecorder) Create(ctx, tx, entry any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Create", reflect.TypeOf((*MockEntryRepository)(nil).Create), ctx, tx, entry)
}

// GetBalanceAtTime mocks base method.
func (m *MockEntryRepository) GetBalanceAtTime(ctx context.Context, accountID string, at time.Time) (decimal.Decimal, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetBalanceAtTime", ctx, accountID, at)
	ret0, _ := ret[0].(decimal.Decimal)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetBalanceAtTime indicates an expected call of GetBalanceAtTime.
func (mr *MockEntryRepositoryMockRecorder) GetBalanceAtTime(ctx, accountID, at any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetBalanceAtTime", reflect.TypeOf((*MockEntryRepository)(nil).GetBalanceAtTime), ctx, accountID, at)
}

// GetByAccount mocks base method.
func (m *MockEntryRepository) GetByAccount(ctx context.Context, accountID string, limit, offset int) ([]*domain.Entry, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetByAccount", ctx, accountID, limit, offset)
	ret0, _ := ret[0].([]*domain.Entry)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetByAccount indicates an expected call of GetByAccount.
func (mr *MockEntryRepositoryMockRecorder) GetByAccount(ctx, accountID, limit, offset any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetByAccount", reflect.TypeOf((*MockEntryRepository)(nil).GetByAccount), ctx, accountID, limit, offset)
}

// GetByTransfer mocks base method.
func (m *MockEntryRepository) GetByTransfer(ctx context.Context, transferID string) ([]*domain.Entry, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetByTransfer", ctx, transferID)
	ret0, _ := ret[0].([]*domain.Entry)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetByTransfer indicates an expected call of GetByTransfer.
func (mr *MockEntryRepositoryMockRecorder) GetByTransfer(ctx, transferID any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetByTransfer", reflect.TypeOf((*MockEntryRepository)(nil).GetByTransfer), ctx, transferID)
}

// MockLedgerRepository is a mock of LedgerRepository interface.
type MockLedgerRepository struct {
	ctrl     *gomock.Controller
	recorder *MockLedgerRepositoryMockRecorder
	isgomock struct{}
}

// MockLedgerRepositoryMockRecorder is the mock recorder for MockLedgerRepository.
type MockLedgerRepositoryMockRecorder struct {
	mock *MockLedgerRepository
}

// NewMockLedgerRepository creates a new mock instance.
func NewMockLedgerRepository(ctrl *gomock.Controller) *MockLedgerRepository {
	mock := &MockLedgerRepository{ctrl: ctrl}
	mock.recorder = &MockLedgerRepositoryMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockLedgerRepository) EXPECT() *MockLedgerRepositoryMockRecorder {
	return m.recorder
}

// CheckConsistency mocks base method.
func (m *MockLedgerRepository) CheckConsistency(ctx context.Context) (decimal.Decimal, decimal.Decimal, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CheckConsistency", ctx)
	ret0, _ := ret[0].(decimal.Decimal)
	ret1, _ := ret[1].(decimal.Decimal)
	ret2, _ := ret[2].(error)
	return ret0, ret1, ret2
}

// CheckConsistency indicates an expected call of CheckConsistency.
func (mr *MockLedgerRepositoryMockRecorder) CheckConsistency(ctx any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CheckConsistency", reflect.TypeOf((*MockLedgerRepository)(nil).CheckConsistency), ctx)
}

// MockHoldRepository is a mock of HoldRepository interface.
type MockHoldRepository struct {
	ctrl     *gomock.Controller
	recorder *MockHoldRepositoryMockRecorder
	isgomock struct{}
}

// MockHoldRepositoryMockRecorder is the mock recorder for MockHoldRepository.
type MockHoldRepositoryMockRecorder struct {
	mock *MockHoldRepository
}

// NewMockHoldRepository creates a new mock instance.
func NewMockHoldRepository(ctrl *gomock.Controller) *MockHoldRepository {
	mock := &MockHoldRepository{ctrl: ctrl}
	mock.recorder = &MockHoldRepositoryMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockHoldRepository) EXPECT() *MockHoldRepositoryMockRecorder {
	return m.recorder
}

// Create mocks base method.
func (m *MockHoldRepository) Create(ctx context.Context, tx usecase.Transaction, hold *domain.Hold) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Create", ctx, tx, hold)
	ret0, _ := ret[0].(error)
	return ret0
}

// Create indicates an expected call of Create.
func (mr *MockHoldRepositoryMockRecorder) Create(ctx, tx, hold any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Create", reflect.TypeOf((*MockHoldRepository)(nil).Create), ctx, tx, hold)
}

// GetByID mocks base method.
func (m *MockHoldRepository) GetByID(ctx context.Context, id string) (*domain.Hold, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetByID", ctx, id)
	ret0, _ := ret[0].(*domain.Hold)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetByID indicates an expected call of GetByID.
func (mr *MockHoldRepositoryMockRecorder) GetByID(ctx, id any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetByID", reflect.TypeOf((*MockHoldRepository)(nil).GetByID), ctx, id)
}

// GetByIDForUpdate mocks base method.
func (m *MockHoldRepository) GetByIDForUpdate(ctx context.Context, tx usecase.Transaction, id string) (*domain.Hold, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetByIDForUpdate", ctx, tx, id)
	ret0, _ := ret[0].(*domain.Hold)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetByIDForUpdate indicates an expected call of GetByIDForUpdate.
func (mr *MockHoldRepositoryMockRecorder) GetByIDForUpdate(ctx, tx, id any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetByIDForUpdate", reflect.TypeOf((*MockHoldRepository)(nil).GetByIDForUpdate), ctx, tx, id)
}

// ListByAccount mocks base method.
func (m *MockHoldRepository) ListByAccount(ctx context.Context, accountID string, limit, offset int) ([]*domain.Hold, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ListByAccount", ctx, accountID, limit, offset)
	ret0, _ := ret[0].([]*domain.Hold)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ListByAccount indicates an expected call of ListByAccount.
func (mr *MockHoldRepositoryMockRecorder) ListByAccount(ctx, accountID, limit, offset any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ListByAccount", reflect.TypeOf((*MockHoldRepository)(nil).ListByAccount), ctx, accountID, limit, offset)
}

// UpdateStatus mocks base method.
func (m *MockHoldRepository) UpdateStatus(ctx context.Context, tx usecase.Transaction, id string, status domain.HoldStatus, updatedAt time.Time) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "UpdateStatus", ctx, tx, id, status, updatedAt)
	ret0, _ := ret[0].(error)
	return ret0
}

// UpdateStatus indicates an expected call of UpdateStatus.
func (mr *MockHoldRepositoryMockRecorder) UpdateStatus(ctx, tx, id, status, updatedAt any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UpdateStatus", reflect.TypeOf((*MockHoldRepository)(nil).UpdateStatus), ctx, tx, id, status, updatedAt)
}

// MockOutboxRepository is a mock of OutboxRepository interface.
type MockOutboxRepository struct {
	ctrl     *gomock.Controller
	recorder *MockOutboxRepositoryMockRecorder
	isgomock struct{}
}

// MockOutboxRepositoryMockRecorder is the mock recorder for MockOutboxRepository.
type MockOutboxRepositoryMockRecorder struct {
	mock *MockOutboxRepository
}

// NewMockOutboxRepository creates a new mock instance.
func NewMockOutboxRepository(ctrl *gomock.Controller) *MockOutboxRepository {
	mock := &MockOutboxRepository{ctrl: ctrl}
	mock.recorder = &MockOutboxRepositoryMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockOutboxRepository) EXPECT() *MockOutboxRepositoryMockRecorder {
	return m.recorder
}

// Create mocks base method.
func (m *MockOutboxRepository) Create(ctx context.Context, tx usecase.Transaction, event *domain.OutboxEvent) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Create", ctx, tx, event)
	ret0, _ := ret[0].(error)
	return ret0
}

// Create indicates an expected call of Create.
func (mr *MockOutboxRepositoryMockRecorder) Create(ctx, tx, event any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Create", reflect.TypeOf((*MockOutboxRepository)(nil).Create), ctx, tx, event)
}

// DeletePublished mocks base method.
func (m *MockOutboxRepository) DeletePublished(ctx context.Context, before time.Time) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "DeletePublished", ctx, before)
	ret0, _ := ret[0].(error)
	return ret0
}

// DeletePublished indicates an expected call of DeletePublished.
func (mr *MockOutboxRepositoryMockRecorder) DeletePublished(ctx, before any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DeletePublished", reflect.TypeOf((*MockOutboxRepository)(nil).DeletePublished), ctx, before)
}

// GetByAggregate mocks base method.
func (m *MockOutboxRepository) GetByAggregate(ctx context.Context, aggregateType, aggregateID string, limit, offset int) ([]*domain.OutboxEvent, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetByAggregate", ctx, aggregateType, aggregateID, limit, offset)
	ret0, _ := ret[0].([]*domain.OutboxEvent)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetByAggregate indicates an expected call of GetByAggregate.
func (mr *MockOutboxRepositoryMockRecorder) GetByAggregate(ctx, aggregateType, aggregateID, limit, offset any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetByAggregate", reflect.TypeOf((*MockOutboxRepository)(nil).GetByAggregate), ctx, aggregateType, aggregateID, limit, offset)
}

// GetUnpublished mocks base method.
func (m *MockOutboxRepository) GetUnpublished(ctx context.Context, limit int) ([]*domain.OutboxEvent, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetUnpublished", ctx, limit)
	ret0, _ := ret[0].([]*domain.OutboxEvent)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetUnpublished indicates an expected call of GetUnpublished.
func (mr *MockOutboxRepositoryMockRecorder) GetUnpublished(ctx, limit any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetUnpublished", reflect.TypeOf((*MockOutboxRepository)(nil).GetUnpublished), ctx, limit)
}

// MarkPublished mocks base method.
func (m *MockOutboxRepository) MarkPublished(ctx context.Context, id string, publishedAt time.Time) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "MarkPublished", ctx, id, publishedAt)
	ret0, _ := ret[0].(error)
	return ret0
}

// MarkPublished indicates an expected call of MarkPublished.
func (mr *MockOutboxRepositoryMockRecorder) MarkPublished(ctx, id, publishedAt any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "MarkPublished", reflect.TypeOf((*MockOutboxRepository)(nil).MarkPublished), ctx, id, publishedAt)
}

// MockAuditRepository is a mock of AuditRepository interface.
type MockAuditRepository struct {
	ctrl     *gomock.Controller
	recorder *MockAuditRepositoryMockRecorder
	isgomock struct{}
}

// MockAuditRepositoryMockRecorder is the mock recorder for MockAuditRepository.
type MockAuditRepositoryMockRecorder struct {
	mock *MockAuditRepository
}

// NewMockAuditRepository creates a new mock instance.
func NewMockAuditRepository(ctrl *gomock.Controller) *MockAuditRepository {
	mock := &MockAuditRepository{ctrl: ctrl}
	mock.recorder = &MockAuditRepositoryMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockAuditRepository) EXPECT() *MockAuditRepositoryMockRecorder {
	return m.recorder
}

// Create mocks base method.
func (m *MockAuditRepository) Create(ctx context.Context, log *domain.AuditLog) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Create", ctx, log)
	ret0, _ := ret[0].(error)
	return ret0
}

// Create indicates an expected call of Create.
func (mr *MockAuditRepositoryMockRecorder) Create(ctx, log any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Create", reflect.TypeOf((*MockAuditRepository)(nil).Create), ctx, log)
}

// CreateTx mocks base method.
func (m *MockAuditRepository) CreateTx(ctx context.Context, tx usecase.Transaction, log *domain.AuditLog) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CreateTx", ctx, tx, log)
	ret0, _ := ret[0].(error)
	return ret0
}

// CreateTx indicates an expected call of CreateTx.
func (mr *MockAuditRepositoryMockRecorder) CreateTx(ctx, tx, log any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CreateTx", reflect.TypeOf((*MockAuditRepository)(nil).CreateTx), ctx, tx, log)
}

// GetByResourceID mocks base method.
func (m *MockAuditRepository) GetByResourceID(ctx context.Context, resourceType, resourceID string) ([]*domain.AuditLog, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetByResourceID", ctx, resourceType, resourceID)
	ret0, _ := ret[0].([]*domain.AuditLog)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetByResourceID indicates an expected call of GetByResourceID.
func (mr *MockAuditRepositoryMockRecorder) GetByResourceID(ctx, resourceType, resourceID any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetByResourceID", reflect.TypeOf((*MockAuditRepository)(nil).GetByResourceID), ctx, resourceType, resourceID)
}

// List mocks base method.
func (m *MockAuditRepository) List(ctx context.Context, filter domain.AuditFilter) ([]*domain.AuditLog, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "List", ctx, filter)
	ret0, _ := ret[0].([]*domain.AuditLog)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// List indicates an expected call of List.
func (mr *MockAuditRepositoryMockRecorder) List(ctx, filter any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "List", reflect.TypeOf((*MockAuditRepository)(nil).List), ctx, filter)
}

// MockTransaction is a mock of Transaction interface.
type MockTransaction struct {
	ctrl     *gomock.Controller
	recorder *MockTransactionMockRecorder
	isgomock struct{}
}

// MockTransactionMockRecorder is the mock recorder for MockTransaction.
type MockTransactionMockRecorder struct {
	mock *MockTransaction
}

// NewMockTransaction creates a new mock instance.
func NewMockTransaction(ctrl *gomock.Controller) *MockTransaction {
	mock := &MockTransaction{ctrl: ctrl}
	mock.recorder = &MockTransactionMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockTransaction) EXPECT() *MockTransactionMockRecorder {
	return m.recorder
}

// Commit mocks base method.
func (m *MockTransaction) Commit(ctx context.Context) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Commit", ctx)
	ret0, _ := ret[0].(error)
	return ret0
}

// Commit indicates an expected call of Commit.
func (mr *MockTransactionMockRecorder) Commit(ctx any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Commit", reflect.TypeOf((*MockTransaction)(nil).Commit), ctx)
}

// Rollback mocks base method.
func (m *MockTransaction) Rollback(ctx context.Context) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Rollback", ctx)
	ret0, _ := ret[0].(error)
	return ret0
}

// Rollback indicates an expected call of Rollback.
func (mr *MockTransactionMockRecorder) Rollback(ctx any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Rollback", reflect.TypeOf((*MockTransaction)(nil).Rollback), ctx)
}

// MockTransactionManager is a mock of TransactionManager interface.
type MockTransactionManager struct {
	ctrl     *gomock.Controller
	recorder *MockTransactionManagerMockRecorder
	isgomock struct{}
}

// MockTransactionManagerMockRecorder is the mock recorder for MockTransactionManager.
type MockTransactionManagerMockRecorder struct {
	mock *MockTransactionManager
}

// NewMockTransactionManager creates a new mock instance.
func NewMockTransactionManager(ctrl *gomock.Controller) *MockTransactionManager {
	mock := &MockTransactionManager{ctrl: ctrl}
	mock.recorder = &MockTransactionManagerMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockTransactionManager) EXPECT() *MockTransactionManagerMockRecorder {
	return m.recorder
}

// Begin mocks base method.
func (m *MockTransactionManager) Begin(ctx context.Context) (usecase.Transaction, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Begin", ctx)
	ret0, _ := ret[0].(usecase.Transaction)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Begin indicates an expected call of Begin.
func (mr *MockTransactionManagerMockRecorder) Begin(ctx any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Begin", reflect.TypeOf((*MockTransactionManager)(nil).Begin), ctx)
}

// MockIDGenerator is a mock of IDGenerator interface.
type MockIDGenerator struct {
	ctrl     *gomock.Controller
	recorder *MockIDGeneratorMockRecorder
	isgomock struct{}
}

// MockIDGeneratorMockRecorder is the mock recorder for MockIDGenerator.
type MockIDGeneratorMockRecorder struct {
	mock *MockIDGenerator
}

// NewMockIDGenerator creates a new mock instance.
func NewMockIDGenerator(ctrl *gomock.Controller) *MockIDGenerator {
	mock := &MockIDGenerator{ctrl: ctrl}
	mock.recorder = &MockIDGeneratorMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockIDGenerator) EXPECT() *MockIDGeneratorMockRecorder {
	return m.recorder
}

// Generate mocks base method.
func (m *MockIDGenerator) Generate() string {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Generate")
	ret0, _ := ret[0].(string)
	return ret0
}

// Generate indicates an expected call of Generate.
func (mr *MockIDGeneratorMockRecorder) Generate() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Generate", reflect.TypeOf((*MockIDGenerator)(nil).Generate))
}

// MockCache is a mock of Cache interface.
type MockCache struct {
	ctrl     *gomock.Controller
	recorder *MockCacheMockRecorder
	isgomock struct{}
}

// MockCacheMockRecorder is the mock recorder for MockCache.
type MockCacheMockRecorder struct {
	mock *MockCache
}

// NewMockCache creates a new mock instance.
func NewMockCache(ctrl *gomock.Controller) *MockCache {
	mock := &MockCache{ctrl: ctrl}
	mock.recorder = &MockCacheMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockCache) EXPECT() *MockCacheMockRecorder {
	return m.recorder
}

// Delete mocks base method.
func (m *MockCache) Delete(ctx context.Context, key string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Delete", ctx, key)
	ret0, _ := ret[0].(error)
	return ret0
}

// Delete indicates an expected call of Delete.
func (mr *MockCacheMockRecorder) Delete(ctx, key any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Delete", reflect.TypeOf((*MockCache)(nil).Delete), ctx, key)
}

// Get mocks base method.
func (m *MockCache) Get(ctx context.Context, key string) ([]byte, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Get", ctx, key)
	ret0, _ := ret[0].([]byte)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Get indicates an expected call of Get.
func (mr *MockCacheMockRecorder) Get(ctx, key any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Get", reflect.TypeOf((*MockCache)(nil).Get), ctx, key)
}

// Set mocks base method.
func (m *MockCache) Set(ctx context.Context, key string, value []byte, ttl time.Duration) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Set", ctx, key, value, ttl)
	ret0, _ := ret[0].(error)
	return ret0
}

// Set indicates an expected call of Set.
func (mr *MockCacheMockRecorder) Set(ctx, key, value, ttl any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Set", reflect.TypeOf((*MockCache)(nil).Set), ctx, key, value, ttl)
}

// MockIdempotencyStore is a mock of IdempotencyStore interface.
type MockIdempotencyStore struct {
	ctrl     *gomock.Controller
	recorder *MockIdempotencyStoreMockRecorder
	isgomock struct{}
}

// MockIdempotencyStoreMockRecorder is the mock recorder for MockIdempotencyStore.
type MockIdempotencyStoreMockRecorder struct {
	mock *MockIdempotencyStore
}

// NewMockIdempotencyStore creates a new mock instance.
func NewMockIdempotencyStore(ctrl *gomock.Controller) *MockIdempotencyStore {
	mock := &MockIdempotencyStore{ctrl: ctrl}
	mock.recorder = &MockIdempotencyStoreMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockIdempotencyStore) EXPECT() *MockIdempotencyStoreMockRecorder {
	return m.recorder
}

// CheckAndSet mocks base method.
func (m *MockIdempotencyStore) CheckAndSet(ctx context.Context, key string, response []byte, ttl time.Duration) (bool, []byte, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CheckAndSet", ctx, key, response, ttl)
	ret0, _ := ret[0].(bool)
	ret1, _ := ret[1].([]byte)
	ret2, _ := ret[2].(error)
	return ret0, ret1, ret2
}

// CheckAndSet indicates an expected call of CheckAndSet.
func (mr *MockIdempotencyStoreMockRecorder) CheckAndSet(ctx, key, response, ttl any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CheckAndSet", reflect.TypeOf((*MockIdempotencyStore)(nil).CheckAndSet), ctx, key, response, ttl)
}

// Update mocks base method.
func (m *MockIdempotencyStore) Update(ctx context.Context, key string, response []byte, ttl time.Duration) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Update", ctx, key, response, ttl)
	ret0, _ := ret[0].(error)
	return ret0
}

// Update indicates an expected call of Update.
func (mr *MockIdempotencyStoreMockRecorder) Update(ctx, key, response, ttl any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Update", reflect.TypeOf((*MockIdempotencyStore)(nil).Update), ctx, key, response, ttl)
}
